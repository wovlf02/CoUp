# 6. ì½”ë“œ ì„¤ëª…

## í”„ë¡œì íŠ¸ êµ¬ì¡°

```
CoUp/
â”œâ”€â”€ coup/                           # Next.js ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/                   # App Router (í˜ì´ì§€ + API)
â”‚   â”‚   â”‚   â”œâ”€â”€ (auth)/           # ì¸ì¦ í˜ì´ì§€ ê·¸ë£¹
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ sign-in/      # ë¡œê·¸ì¸
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ sign-up/      # íšŒì›ê°€ì…
â”‚   â”‚   â”‚   â”œâ”€â”€ (legal)/          # ë²•ì  í˜ì´ì§€ ê·¸ë£¹
â”‚   â”‚   â”‚   â”œâ”€â”€ admin/            # ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œ
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard/        # ë©”ì¸ ëŒ€ì‹œë³´ë“œ
â”‚   â”‚   â”‚   â”œâ”€â”€ studies/          # ìŠ¤í„°ë”” íƒìƒ‰
â”‚   â”‚   â”‚   â”œâ”€â”€ my-studies/       # ë‚´ ìŠ¤í„°ë”” ìƒì„¸
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [studyId]/    # ë™ì  ë¼ìš°íŒ…
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ chat/     # ì±„íŒ…
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ calendar/ # ìº˜ë¦°ë”
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ notices/  # ê³µì§€ì‚¬í•­
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ files/    # íŒŒì¼
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ members/  # ë©¤ë²„ ê´€ë¦¬
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ video-call/ # í™”ìƒ í†µí™”
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ settings/ # ì„¤ì •
â”‚   â”‚   â”‚   â”œâ”€â”€ tasks/            # í• ì¼ ê´€ë¦¬
â”‚   â”‚   â”‚   â”œâ”€â”€ notifications/    # ì•Œë¦¼
â”‚   â”‚   â”‚   â”œâ”€â”€ me/               # ë§ˆì´í˜ì´ì§€
â”‚   â”‚   â”‚   â”œâ”€â”€ settings/         # ì„¤ì •
â”‚   â”‚   â”‚   â””â”€â”€ api/              # API Routes
â”‚   â”‚   â”‚       â”œâ”€â”€ auth/         # ì¸ì¦ API
â”‚   â”‚   â”‚       â”œâ”€â”€ studies/      # ìŠ¤í„°ë”” API
â”‚   â”‚   â”‚       â”œâ”€â”€ tasks/        # í• ì¼ API
â”‚   â”‚   â”‚       â”œâ”€â”€ admin/        # ê´€ë¦¬ì API
â”‚   â”‚   â”‚       â””â”€â”€ ...
â”‚   â”‚   â”œâ”€â”€ components/           # React ì»´í¬ë„ŒíŠ¸
â”‚   â”‚   â”‚   â”œâ”€â”€ common/           # ê³µí†µ ì»´í¬ë„ŒíŠ¸
â”‚   â”‚   â”‚   â”œâ”€â”€ layout/           # ë ˆì´ì•„ì›ƒ
â”‚   â”‚   â”‚   â”œâ”€â”€ study/            # ìŠ¤í„°ë”” ê´€ë ¨
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard/        # ëŒ€ì‹œë³´ë“œ
â”‚   â”‚   â”‚   â”œâ”€â”€ video-call/       # í™”ìƒí†µí™”
â”‚   â”‚   â”‚   â””â”€â”€ admin/            # ê´€ë¦¬ì
â”‚   â”‚   â”œâ”€â”€ lib/                  # ìœ í‹¸ë¦¬í‹° & ì„¤ì •
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.js           # NextAuth ì„¤ì •
â”‚   â”‚   â”‚   â”œâ”€â”€ prisma.js         # Prisma í´ë¼ì´ì–¸íŠ¸
â”‚   â”‚   â”‚   â”œâ”€â”€ api.js            # API í´ë¼ì´ì–¸íŠ¸
â”‚   â”‚   â”‚   â”œâ”€â”€ hooks/            # Custom Hooks
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useApi.js     # API ê´€ë ¨ í›…
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useSocket.js  # ì†Œì¼“ í›…
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ useVideoCall.js # í™”ìƒí†µí™” í›…
â”‚   â”‚   â”‚   â””â”€â”€ validators/       # Zod ìŠ¤í‚¤ë§ˆ
â”‚   â”‚   â”œâ”€â”€ contexts/             # React Context
â”‚   â”‚   â”œâ”€â”€ styles/               # ê¸€ë¡œë²Œ ìŠ¤íƒ€ì¼
â”‚   â”‚   â””â”€â”€ utils/                # í—¬í¼ í•¨ìˆ˜
â”‚   â”œâ”€â”€ prisma/
â”‚   â”‚   â”œâ”€â”€ schema.prisma         # DB ìŠ¤í‚¤ë§ˆ
â”‚   â”‚   â”œâ”€â”€ migrations/           # ë§ˆì´ê·¸ë ˆì´ì…˜
â”‚   â”‚   â””â”€â”€ seed.js               # ì‹œë“œ ë°ì´í„°
â”‚   â”œâ”€â”€ scripts/                  # ìœ í‹¸ë¦¬í‹° ìŠ¤í¬ë¦½íŠ¸
â”‚   â”œâ”€â”€ public/                   # ì •ì  íŒŒì¼
â”‚   â””â”€â”€ logs/                     # ë¡œê·¸ íŒŒì¼
â”‚
â”œâ”€â”€ signaling-server/              # Socket.IO ì‹œê·¸ë„ë§ ì„œë²„
â”‚   â”œâ”€â”€ server.js                 # ë©”ì¸ ì„œë²„
â”‚   â”œâ”€â”€ handlers/                 # ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
â”‚   â”‚   â”œâ”€â”€ video.js              # í™”ìƒ í†µí™”
â”‚   â”‚   â”œâ”€â”€ chat.js               # ì±„íŒ…
â”‚   â”‚   â””â”€â”€ presence.js           # ì˜¨ë¼ì¸ ìƒíƒœ
â”‚   â”œâ”€â”€ middleware/               # ì¸ì¦ ë¯¸ë“¤ì›¨ì–´
â”‚   â””â”€â”€ utils/                    # ìœ í‹¸ë¦¬í‹°
â”‚
â”œâ”€â”€ docs/                          # í”„ë¡œì íŠ¸ ë¬¸ì„œ
â””â”€â”€ docker-compose.yml            # Docker ì„¤ì •
```

---

## í•µì‹¬ ì½”ë“œ ì„¤ëª…

### 1. API Route ì˜ˆì‹œ (ìŠ¤í„°ë”” ëª©ë¡ ì¡°íšŒ)

```javascript
// src/app/api/studies/route.js

import { NextResponse } from "next/server"
import { requireAuth } from "@/lib/auth-helpers"
import { prisma } from "@/lib/prisma"

export async function GET(request) {
  // ì¸ì¦ ê²€ì‚¬ (ì„ íƒì )
  const session = await requireAuth()
  
  try {
    const { searchParams } = new URL(request.url)
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '20')
    const category = searchParams.get('category')
    const search = searchParams.get('search')
    
    // í•„í„° ì¡°ê±´ êµ¬ì„±
    const whereClause = {
      isPublic: true,
      ...(category && { category }),
      ...(search && {
        OR: [
          { name: { contains: search, mode: 'insensitive' } },
          { description: { contains: search, mode: 'insensitive' } }
        ]
      })
    }
    
    // ë³‘ë ¬ ì¿¼ë¦¬ ì‹¤í–‰ (ì´ ê°œìˆ˜ + ë°ì´í„°)
    const [total, studies] = await Promise.all([
      prisma.study.count({ where: whereClause }),
      prisma.study.findMany({
        where: whereClause,
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { createdAt: 'desc' },
        include: {
          owner: { select: { id: true, name: true, avatar: true } },
          _count: { select: { members: { where: { status: 'ACTIVE' } } } }
        }
      })
    ])
    
    return NextResponse.json({
      success: true,
      data: studies,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    })
    
  } catch (error) {
    console.error('Get studies error:', error)
    return NextResponse.json(
      { error: "ìŠ¤í„°ë”” ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤" },
      { status: 500 }
    )
  }
}
```

### 2. TanStack Query í›… (useApi.js)

```javascript
// src/lib/hooks/useApi.js

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import api from '@/lib/api'

// ìŠ¤í„°ë”” ëª©ë¡ ì¡°íšŒ í›…
export function useStudies(params = {}) {
  const queryString = new URLSearchParams(params).toString()
  
  return useQuery({
    queryKey: ['studies', params],
    queryFn: () => api.get(`/api/studies?${queryString}`),
    staleTime: 1000 * 60 * 5, // 5ë¶„ê°„ ìºì‹œ ìœ ì§€
  })
}

// ë‹¨ì¼ ìŠ¤í„°ë”” ì¡°íšŒ í›…
export function useStudy(studyId) {
  return useQuery({
    queryKey: ['study', studyId],
    queryFn: () => api.get(`/api/studies/${studyId}`),
    enabled: !!studyId, // studyIdê°€ ìˆì„ ë•Œë§Œ ì‹¤í–‰
  })
}

// ìŠ¤í„°ë”” ìƒì„± Mutation
export function useCreateStudy() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: (data) => api.post('/api/studies', data),
    onSuccess: () => {
      // ìºì‹œ ë¬´íš¨í™” â†’ ëª©ë¡ ìë™ ê°±ì‹ 
      queryClient.invalidateQueries({ queryKey: ['studies'] })
    }
  })
}

// ë©”ì‹œì§€ ì¡°íšŒ í›…
export function useMessages(studyId, options = {}) {
  return useQuery({
    queryKey: ['messages', studyId],
    queryFn: () => api.get(`/api/my-studies/${studyId}/messages`),
    enabled: !!studyId,
    refetchInterval: 30000, // 30ì´ˆë§ˆë‹¤ ìë™ ê°±ì‹ 
  })
}

// ë©”ì‹œì§€ ì „ì†¡ Mutation
export function useSendMessage() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: ({ studyId, content }) => 
      api.post(`/api/my-studies/${studyId}/messages`, { content }),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: ['messages', variables.studyId] })
    }
  })
}

// ëŒ€ì‹œë³´ë“œ ë°ì´í„° í›…
export function useDashboard() {
  return useQuery({
    queryKey: ['dashboard'],
    queryFn: () => api.get('/api/dashboard'),
    staleTime: 1000 * 60 * 2, // 2ë¶„
  })
}
```

### 3. Socket.IO ì—°ê²° í›… (useSocket.js)

```javascript
// src/lib/hooks/useSocket.js

import { useEffect, useState, useCallback } from 'react'
import { useSession } from 'next-auth/react'
import { io } from 'socket.io-client'

const SOCKET_URL = process.env.NEXT_PUBLIC_SOCKET_URL || 'http://localhost:4000'

export function useSocket() {
  const { data: session } = useSession()
  const [socket, setSocket] = useState(null)
  const [isConnected, setIsConnected] = useState(false)
  
  useEffect(() => {
    if (!session?.accessToken) return
    
    // ì†Œì¼“ ì—°ê²° ìƒì„±
    const socketInstance = io(SOCKET_URL, {
      auth: { token: session.accessToken },
      transports: ['websocket', 'polling'],
      reconnectionAttempts: 5
    })
    
    socketInstance.on('connect', () => {
      console.log('Socket connected:', socketInstance.id)
      setIsConnected(true)
    })
    
    socketInstance.on('disconnect', (reason) => {
      console.log('Socket disconnected:', reason)
      setIsConnected(false)
    })
    
    socketInstance.on('connect_error', (error) => {
      console.error('Socket connection error:', error)
    })
    
    setSocket(socketInstance)
    
    // í´ë¦°ì—…
    return () => {
      socketInstance.disconnect()
    }
  }, [session?.accessToken])
  
  // ì´ë²¤íŠ¸ ë°œì†¡ í—¬í¼
  const emit = useCallback((event, data) => {
    if (socket?.connected) {
      socket.emit(event, data)
    }
  }, [socket])
  
  return { socket, isConnected, emit }
}
```

### 4. í™”ìƒ í†µí™” í›… (useVideoCall.js)

```javascript
// src/lib/hooks/useVideoCall.js (ê°„ëµí™”)

export function useVideoCall({ socket, roomId, currentUser }) {
  const [localStream, setLocalStream] = useState(null)
  const [remoteStreams, setRemoteStreams] = useState(new Map())
  const peerConnections = useRef(new Map())
  
  // ë¡œì»¬ ë¯¸ë””ì–´ ìŠ¤íŠ¸ë¦¼ íšë“
  const startLocalStream = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
      })
      setLocalStream(stream)
      return stream
    } catch (error) {
      console.error('Failed to get local stream:', error)
    }
  }, [])
  
  // ë°© ì…ì¥
  const joinRoom = useCallback(() => {
    if (!socket || !roomId) return
    
    socket.emit('video:join-room', {
      roomId,
      studyId: roomId.split('-')[1]
    })
  }, [socket, roomId])
  
  // WebRTC Peer Connection ìƒì„±
  const createPeerConnection = useCallback((targetSocketId) => {
    const pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    })
    
    // ë¡œì»¬ íŠ¸ë™ ì¶”ê°€
    localStream?.getTracks().forEach(track => {
      pc.addTrack(track, localStream)
    })
    
    // ICE Candidate ì²˜ë¦¬
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        socket.emit('video:ice-candidate', {
          to: targetSocketId,
          candidate: event.candidate
        })
      }
    }
    
    // ì›ê²© ìŠ¤íŠ¸ë¦¼ ìˆ˜ì‹ 
    pc.ontrack = (event) => {
      setRemoteStreams(prev => {
        const newMap = new Map(prev)
        newMap.set(targetSocketId, event.streams[0])
        return newMap
      })
    }
    
    peerConnections.current.set(targetSocketId, pc)
    return pc
  }, [localStream, socket])
  
  // Offer ìƒì„± ë° ì „ì†¡
  const createOffer = useCallback(async (targetSocketId) => {
    const pc = createPeerConnection(targetSocketId)
    const offer = await pc.createOffer()
    await pc.setLocalDescription(offer)
    
    socket.emit('video:offer', {
      to: targetSocketId,
      offer
    })
  }, [createPeerConnection, socket])
  
  // Socket ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
  useEffect(() => {
    if (!socket) return
    
    // ìƒˆ ì°¸ì—¬ì ì…ì¥
    socket.on('video:user-joined', async ({ socketId }) => {
      await createOffer(socketId)
    })
    
    // Offer ìˆ˜ì‹  â†’ Answer ìƒì„±
    socket.on('video:offer', async ({ from, offer }) => {
      const pc = createPeerConnection(from)
      await pc.setRemoteDescription(new RTCSessionDescription(offer))
      const answer = await pc.createAnswer()
      await pc.setLocalDescription(answer)
      
      socket.emit('video:answer', { to: from, answer })
    })
    
    // Answer ìˆ˜ì‹ 
    socket.on('video:answer', async ({ from, answer }) => {
      const pc = peerConnections.current.get(from)
      if (pc) {
        await pc.setRemoteDescription(new RTCSessionDescription(answer))
      }
    })
    
    // ICE Candidate ìˆ˜ì‹ 
    socket.on('video:ice-candidate', async ({ from, candidate }) => {
      const pc = peerConnections.current.get(from)
      if (pc) {
        await pc.addIceCandidate(new RTCIceCandidate(candidate))
      }
    })
    
    return () => {
      socket.off('video:user-joined')
      socket.off('video:offer')
      socket.off('video:answer')
      socket.off('video:ice-candidate')
    }
  }, [socket, createOffer, createPeerConnection])
  
  return {
    localStream,
    remoteStreams,
    startLocalStream,
    joinRoom,
    // ... ê¸°íƒ€ í•¨ìˆ˜
  }
}
```

### 5. ì‹œê·¸ë„ë§ ì„œë²„ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬

```javascript
// signaling-server/handlers/video.js

export function handleVideoEvents(socket, io) {
  // í™”ìƒ í†µí™” ë°© ì…ì¥
  socket.on('video:join-room', async ({ studyId, roomId }) => {
    socket.join(`video:${roomId}`)
    socket.currentVideoRoom = roomId
    
    // ë°© ì°¸ì—¬ì ì •ë³´ ì €ì¥
    if (!videoRooms.has(roomId)) {
      videoRooms.set(roomId, new Map())
    }
    
    videoRooms.get(roomId).set(socket.id, {
      socketId: socket.id,
      userId: socket.userId,
      user: socket.user,
      joinedAt: new Date()
    })
    
    // ê¸°ì¡´ ì°¸ì—¬ì ëª©ë¡ ì „ì†¡
    const participants = Array.from(videoRooms.get(roomId).values())
      .filter(p => p.socketId !== socket.id)
    
    socket.emit('video:room-state', { participants })
    
    // ë‹¤ë¥¸ ì°¸ì—¬ìë“¤ì—ê²Œ ì•Œë¦¼
    socket.to(`video:${roomId}`).emit('video:user-joined', {
      socketId: socket.id,
      userId: socket.userId,
      user: socket.user
    })
  })
  
  // WebRTC Offer ì „ë‹¬
  socket.on('video:offer', ({ to, offer }) => {
    io.to(to).emit('video:offer', {
      from: socket.id,
      offer
    })
  })
  
  // WebRTC Answer ì „ë‹¬
  socket.on('video:answer', ({ to, answer }) => {
    io.to(to).emit('video:answer', {
      from: socket.id,
      answer
    })
  })
  
  // ICE Candidate ì „ë‹¬
  socket.on('video:ice-candidate', ({ to, candidate }) => {
    io.to(to).emit('video:ice-candidate', {
      from: socket.id,
      candidate
    })
  })
  
  // ë°© í‡´ì¥
  socket.on('video:leave-room', () => {
    const roomId = socket.currentVideoRoom
    if (roomId && videoRooms.has(roomId)) {
      videoRooms.get(roomId).delete(socket.id)
      socket.leave(`video:${roomId}`)
      
      // ë‹¤ë¥¸ ì°¸ì—¬ìë“¤ì—ê²Œ ì•Œë¦¼
      socket.to(`video:${roomId}`).emit('video:user-left', {
        socketId: socket.id
      })
    }
  })
}
```

### 6. ì¸ì¦ ë¯¸ë“¤ì›¨ì–´

```javascript
// src/lib/auth-helpers.js

import { getServerSession } from "next-auth"
import { NextResponse } from "next/server"
import { authOptions } from "@/lib/auth"

// API ë³´í˜¸ìš© í—¬í¼
export async function requireAuth() {
  const session = await getServerSession(authOptions)
  
  if (!session || !session.user) {
    return NextResponse.json(
      { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
      { status: 401 }
    )
  }
  
  return session
}

// ê´€ë¦¬ì ê¶Œí•œ ê²€ì‚¬
export async function requireAdmin() {
  const session = await getServerSession(authOptions)
  
  if (!session || !session.user) {
    return NextResponse.json(
      { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤" },
      { status: 401 }
    )
  }
  
  if (session.user.role !== 'ADMIN') {
    return NextResponse.json(
      { error: "ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤" },
      { status: 403 }
    )
  }
  
  return session
}

// ìŠ¤í„°ë”” ë©¤ë²„ ê¶Œí•œ ê²€ì‚¬
export async function requireStudyMember(studyId, minRole = 'MEMBER') {
  const session = await getServerSession(authOptions)
  
  if (!session) {
    return { error: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤", status: 401 }
  }
  
  const member = await prisma.studyMember.findUnique({
    where: {
      studyId_userId: {
        studyId,
        userId: session.user.id
      }
    }
  })
  
  if (!member || member.status !== 'ACTIVE') {
    return { error: "ìŠ¤í„°ë”” ë©¤ë²„ê°€ ì•„ë‹™ë‹ˆë‹¤", status: 403 }
  }
  
  const roleHierarchy = { OWNER: 3, ADMIN: 2, MEMBER: 1 }
  if (roleHierarchy[member.role] < roleHierarchy[minRole]) {
    return { error: "ê¶Œí•œì´ ë¶€ì¡±í•©ë‹ˆë‹¤", status: 403 }
  }
  
  return { session, member }
}
```

---

## ì»´í¬ë„ŒíŠ¸ ì˜ˆì‹œ

### ëŒ€ì‹œë³´ë“œ í´ë¼ì´ì–¸íŠ¸ ì»´í¬ë„ŒíŠ¸

```javascript
// src/components/dashboard/DashboardClient.jsx

'use client'

import Link from 'next/link'
import styles from '@/app/dashboard/page.module.css'
import { useDashboard, useMe } from '@/lib/hooks/useApi'
import DashboardSkeleton from './DashboardSkeleton'
import StudyStatus from './widgets/StudyStatus'
import QuickActions from './widgets/QuickActions'
import UrgentTasks from './widgets/UrgentTasks'

export default function DashboardClient({ user: initialUser }) {
  const { data: dashboardData, isLoading } = useDashboard()
  const { data: userData } = useMe()
  
  const user = userData?.user || initialUser
  
  if (isLoading) {
    return <DashboardSkeleton />
  }
  
  const { stats, myStudies, upcomingEvents, widgetData } = dashboardData.data
  
  return (
    <div className={styles.container}>
      {/* í™˜ì˜ ë©”ì‹œì§€ */}
      <div className={styles.welcomeSection}>
        <p>ì•ˆë…•í•˜ì„¸ìš”, {user.name}ë‹˜! ğŸ‘‹</p>
      </div>
      
      {/* í†µê³„ ì¹´ë“œ */}
      <div className={styles.statsGrid}>
        <StatCard icon="ğŸ“š" label="í™œì„± ìŠ¤í„°ë””" value={stats.activeStudies} />
        <StatCard icon="âœ…" label="ì§„í–‰ ì¤‘ í• ì¼" value={stats.pendingTasks} />
        <StatCard icon="ğŸ””" label="ì•Œë¦¼" value={stats.unreadNotifications} />
        <StatCard icon="ğŸ¯" label="ì´ë²ˆ ë‹¬ ì™„ë£Œ" value={stats.completedThisMonth} />
      </div>
      
      {/* ë‚´ ìŠ¤í„°ë”” */}
      <section className={styles.section}>
        <h2>ë‚´ ìŠ¤í„°ë””</h2>
        <div className={styles.studyGrid}>
          {myStudies.map(study => (
            <StudyCard key={study.id} study={study} />
          ))}
        </div>
      </section>
      
      {/* ìœ„ì ¯ë“¤ */}
      <div className={styles.widgetsGrid}>
        <StudyStatus data={widgetData?.stats} />
        <QuickActions />
        <UrgentTasks tasks={widgetData?.urgentTasks} />
      </div>
    </div>
  )
}
```

